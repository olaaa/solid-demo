
Принципы остаются теми же:

- **OCP** — открытость для расширения: новый обработчик события добавляется без изменения основного кода
- **DIP** — зависимость от абстракций (интерфейсов)
- **Event-driven** (E из IDEALS) — асинхронное общение через события (теперь через Pulsar topics и subscriptions)

### Сценарий остаётся тем же

Микросервис **Order Service** создаёт заказ → публикует событие `OrderCreatedEvent`.  
Несколько независимых обработчиков реагируют:

- Резервирование товара
- Инициирование оплаты
- Отправка уведомления

Новый обработчик (например, начисление бонусов) добавляется просто новым классом.

### Структура проекта (упрощённо)

```
### Структура проекта (упрощённо)

    src/main/java/com/example/order
    ├── domain
    │   ├── OrderCreatedEvent.java         // доменное событие
    │   └── OutboxEvent.java               // JPA-сущность для transactional outbox
    ├── producer
    │   └── OrderEventProducer.java        // публикация событий в Pulsar
    ├── repository
    │   └── OutboxRepository.java          // Spring Data JPA репозиторий для outbox
    ├── service
    │   ├── handlers
    │   │   ├── OrderEventHandler.java            // интерфейс (DIP + OCP)
    │   │   ├── InventoryReservationHandler.java
    │   │   ├── PaymentInitiationHandler.java
    │   │   └── NotificationHandler.java
    │   ├── OrderEventConsumer.java        // Pulsar consumer с manual ack и DLQ
    │   ├── OrderService.java             // создание заказа + запись в outbox
    │   └── OutboxProcessor.java          // @Scheduled: отправка событий из БД в Pulsar
    └── OrderApplication.java             // точка входа Spring Boot
```

### Как это реализует принципы

- **DIP**: `OutboxProcessor` зависит от абстракции `OrderEventProducer`.  
  `OrderEventConsumer` получает список интерфейсов `OrderEventHandler` через конструктор (Spring их собирает автоматически).

- **OCP**: Новый обработчик — просто новый `@Component`, реализующий `OrderEventHandler`.  
  Spring Boot + PulsarListener автоматически подхватывают все bean'ы. Ничего в `OrderService` или `OrderEventConsumer` менять не нужно.

- **Event-driven**: Полностью асинхронно через Pulsar.  
  Преимущества Pulsar по сравнению с Kafka в этом сценарии:
    - встроенная поддержка multi-tenancy и namespaces
    - гибкие подписки (exclusive, shared, failover)
    - tiered storage (можно хранить старые события дешево)
    - Kafka-совместимый API (если нужно мигрировать позже)

В production реализовано:

- **Transactional outbox**: события сначала сохраняются в БД (таблица `outbox_events`) в одной транзакции с бизнес-логикой, а затем отдельный процесс `OutboxProcessor` отправляет их в Pulsar.
- **Acknowledgment**: настроен `MANUAL` режим подтверждения. Если хотя бы один обработчик завершается с ошибкой, вызывается `nack()`, что инициирует повторную доставку.
- **Dead-letter topics**: после 3 неудачных попыток событие отправляется в `order-created-dlq`.
- **Tracing**: интегрированы Micrometer Tracing и OpenTelemetry (настроено через `application.yml` и зависимости в `pom.xml`).

В проект внесены следующие изменения для обеспечения надежности и наблюдаемости:

### 1. Transactional Outbox
- Добавлена сущность `OutboxEvent` и репозиторий `OutboxRepository` (Spring Data JPA).
- `OrderService` теперь сохраняет события в базу данных (H2) в рамках транзакции, вместо прямой отправки в Pulsar.
- Реализован `OutboxProcessor`, который периодически (`@Scheduled`) считывает необработанные события из БД и отправляет их в Pulsar, гарантируя доставку "at-least-once".

### 2. Acknowledgment & Dead-letter Topics
- В `application.yml` настроен режим подтверждения `manual`.
- В `OrderEventConsumer` добавлена логика обработки подтверждений:
  - `acknowledgement.acknowledge()` вызывается при успешной обработке всеми хендлерами.
  - `acknowledgement.nack()` вызывается при возникновении ошибок, что приводит к повторной доставке.
- Настроена `dead-letter-policy`: после 3 неудачных попыток событие перемещается в топик `order-created-dlq`.  
  Стратегия совместимости (schema compatibility) — это правило, **разрешено ли менять схему сообщения так, чтобы новые и старые приложения могли продолжать общаться**.

Проще:
- **BACKWARD** — новые потребители должны уметь читать **старые** сообщения. (Вы добавляете поля с дефолтами и т.п.)
- **FORWARD** — старые потребители должны уметь читать **новые** сообщения.
- **FULL** — и backward, и forward одновременно.

Это защищает от поломок при эволюции схемы: вы меняете структуру события, а брокер проверяет, **совместимо ли изменение** с уже зарегистрированными схемами.  
если вы не задаёте стратегию совместимости, то используется дефолт брокера Pulsar. В большинстве установок это политика совместимости, заданная на уровне брокера/кластера (часто FULL, но зависит от конфигурации). В приложении Spring сама по себе ничего не включает — она лишь отправляет/читает схемы.

### 4. Tracing (Micrometer + OpenTelemetry)
- В `pom.xml` добавлены зависимости для Micrometer Tracing и OpenTelemetry.
- В `application.yml` включено сэмплирование трасс (100%) и настроен экспорт данных в формате OTLP.  
  Это означает, что **сэмплер трассировки настроен на 100%** — то есть **каждый запрос/операция будет трассироваться и отправляться в систему наблюдаемости** (например, в OpenTelemetry/OTLP).

```yaml
management:
  tracing:
    sampling:
      probability: 1.0
```
- `1.0` → **все** трассы
- `0.1` → **10%** трасс
- `0.0` → **ничего не трассировать**

В продакшене обычно ставят меньше, чтобы снизить нагрузку и объём данных.

### 5. Обновление документации
- `README.md` обновлен: раздел "рекомендуется" заменен на описание реализованной функциональности.

Все изменения соответствуют принципам SOLID и лучшим практикам построения событийно-ориентированных систем.